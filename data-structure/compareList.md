# 배열(Array)와 링크드 리스트(Linked List) 차이점

## 개요
배열과 링크드 리스트는 모두 데이터를 순차적으로 저장하는 자료 구조입니다. 하지만 **저장 방식**과 **연산의 효율성**에서 큰 차이가 있습니다. 각각의 특성과 주요 연산의 시간 복잡도를 비교하여, 언제 어떤 자료 구조가 더 적합한지 알아보겠습니다.

---

## 1. 배열 (Array)

### 특징
- **연속된 메모리**에 데이터가 저장됩니다.
- 인덱스를 통해 **임의 접근**이 가능합니다.
- 크기가 고정되며, 초기화 시 크기를 설정해야 합니다.
- JavaScript에서는 배열 크기를 미리 선언하지 않아도 **자동으로 크기가 확장**됩니다.

### JavaScript 배열의 동적 확장
JavaScript 배열은 내부적으로 동적 배열(dynamic array)로 구현되어 있어 크기를 선언하지 않아도 사용할 수 있습니다. 요소가 추가될 때마다 다음과 같이 처리됩니다:
1. **여유 공간이 있을 때**: 배열의 여유 공간이 남아 있을 경우, 메모리 복사 없이 상수 시간(`O(1)`)에 요소를 추가할 수 있습니다.
2. **여유 공간이 없을 때**: 배열의 여유 공간이 꽉 차면, JavaScript 엔진이 **배열의 크기를 2배로 확장**하고, 모든 요소를 새로운 메모리 공간에 복사합니다. 이 과정은 `O(n)`의 시간이 걸리지만, 확장이 자주 일어나지 않으므로 **평균적으로는 상수 시간(`O(1)`)**에 가까운 효율을 유지할 수 있습니다.

### 주요 연산 시간 복잡도
- **삽입**
    - **끝에 삽입 (Push)**: `O(1)` (평균적으로 상수 시간, 드물게 `O(n)`)
    - **앞 또는 중간에 삽입**: `O(n)` (다른 요소를 이동해야 하기 때문)

- **삭제**
    - **끝에서 삭제 (Pop)**: `O(1)`
    - **앞 또는 중간에서 삭제**: `O(n)` (다른 요소를 이동해야 하기 때문)

- **탐색**
    - **인덱스를 통한 접근**: `O(1)`
    - **값을 통한 탐색**: `O(n)` (순차적으로 찾아야 함)
    - **정렬된 배열에서의 이진 탐색**: `O(log n)`

### 사용이 적합한 경우
- **임의 접근**이 잦고 데이터가 **고정된 크기**일 때
- 특정 위치에 대한 **빈번한 참조**가 필요한 경우
- 데이터의 크기를 **미리 알 수 있는 경우**

---

## 2. 링크드 리스트 (Linked List)

### 특징
- **노드** 단위로 데이터가 저장되며, 각 노드는 다음 노드를 가리키는 **포인터**를 포함합니다.
- **동적 크기** 관리가 가능하며, 메모리가 연속적일 필요가 없습니다.
- 배열과 달리 인덱스를 통해 **직접 접근 불가능**합니다.

### 주요 연산 시간 복잡도
- **삽입**
    - **앞에 삽입**: `O(1)`
    - **중간 또는 끝에 삽입**: `O(n)` (해당 위치까지 순차적으로 이동 필요)

- **삭제**
    - **앞에서 삭제**: `O(1)`
    - **중간 또는 끝에서 삭제**: `O(n)` (해당 위치까지 순차적으로 이동 필요)

- **탐색**
    - **특정 값 탐색**: `O(n)` (순차적으로 찾아야 함)
    - **정렬된 리스트라도** 임의 접근이 불가능해 이진 탐색을 사용할 수 없음

### 사용이 적합한 경우
- 데이터의 **삽입/삭제가 빈번**하게 발생하는 경우
- 데이터의 크기를 **미리 알 수 없거나** 자주 변경되는 경우
- **연속적인 메모리 할당이 어렵거나 제한된 시스템**에서
- 특정 위치보다는 데이터 **연결 자체가 중요한 경우**

---

## 배열과 링크드 리스트 비교 요약

| 연산       | 배열 (Array)             | 링크드 리스트 (Linked List)         |
|------------|---------------------------|-------------------------------------|
| 삽입       | 끝: `O(1)`(평균), 중간/앞: `O(n)` | 앞: `O(1)`, 중간/끝: `O(n)`       |
| 삭제       | 끝: `O(1)`, 중간/앞: `O(n)` | 앞: `O(1)`, 중간/끝: `O(n)`       |
| 탐색       | 인덱스 접근: `O(1)`, 값 탐색: `O(n)` | 값 탐색: `O(n)`                 |
| 메모리     | 연속된 메모리 필요, 고정 크기  | 동적 크기 조정 가능, 연속 메모리 필요 없음 |

---

## 결론
- **배열**은 임의 접근이 필요하고, 요소의 추가/삭제가 드물거나 끝에서만 이루어지는 경우 적합합니다.
- **링크드 리스트**는 삽입/삭제가 빈번히 발생하거나, 크기를 예측할 수 없는 데이터 구조에 적합합니다.

배열과 링크드 리스트 각각의 장단점을 이해하여, 상황에 맞는 자료 구조를 선택하는 것이 중요합니다.


아래는 `그런데 말입니다...` 부분을 **Markdown 형식**으로 작성한 예시입니다. 이 형식을 그대로 복사하여 Markdown 파일에 추가하면 됩니다.

---

## 그런데 말입니다...

### 실험 결과

```
=== Array vs Linked List Insertion Speed for 100000 elements ===
Array Start Insertion: 6.65ms
Linked List Start Insertion: 1.641ms
Array Middle Deletion: 0.005ms
Linked List Middle Deletion: 0.164ms
```

### 결과 분석

#### 시작 부분 삽입
- **배열 (Array)**: `unshift` 메서드는 배열 시작 부분에 요소를 추가할 때 나머지 요소들을 이동시켜야 하므로 `O(n)`의 시간이 걸립니다.
  - **측정 결과**: `Array Start Insertion: 6.65ms`
- **단방향 링크드 리스트 (Linked List)**: 시작 부분에 노드를 추가하는 데 `O(1)`의 시간이 걸립니다. 따라서 배열보다 훨씬 빠르게 수행됩니다.
  - **측정 결과**: `Linked List Start Insertion: 1.641ms`

#### 중간 삭제
- **배열 (Array)**: 중간 요소를 삭제할 때, 나머지 요소들을 이동시켜야 하므로 `O(n)`의 시간이 걸립니다. 하지만 JavaScript의 배열은 **동적 배열(dynamic array)** 로 구현되어 있어 중간 삭제도 작은 데이터에서는 매우 빠르게 수행될 수 있습니다.
  - **측정 결과**: `Array Middle Deletion: 0.005ms`
- **단방향 링크드 리스트 (Linked List)**: 중간 요소를 삭제할 때 해당 위치까지 순회해야 하므로 `O(n)`의 시간이 걸립니다. 중간 위치로 접근하는 데 시간이 걸리기 때문에 작은 데이터에서는 배열보다 느리게 수행됩니다.
  - **측정 결과**: `Linked List Middle Deletion: 0.164ms`

### 결론

- **배열 (Array)**: JavaScript의 배열은 동적 배열로 구현되어 있어 **크기를 미리 지정하지 않아도** 요소 추가 시 자동으로 확장됩니다. 이로 인해 배열의 끝이나 중간에서도 유연하게 삽입/삭제가 가능하며, 데이터가 적을 때는 성능이 매우 빠릅니다. 임의 접근이 필요하고, 요소의 추가/삭제가 드물거나 끝에서만 이루어지는 경우에 적합합니다.

- **단방향 링크드 리스트 (Linked List)**: 삽입/삭제가 빈번히 발생하거나, 크기를 예측할 수 없는 데이터 구조에 적합합니다. 특히, 시작 부분에서의 삽입과 삭제가 빠르기 때문에 특정 위치에 대한 직접 접근이 필요 없는 경우 유리합니다. 하지만 JavaScript 배열의 동적 배열 특성 덕분에, 중간 접근이 필요하다면 배열이 더 유리할 수 있습니다.

이 실험 결과를 통해 각 자료 구조가 특정 시나리오에서 어떤 성능을 보이는지 확인할 수 있으며, 자료 구조 선택 시 JavaScript 배열의 동적 배열 특성과 같은 언어의 특성을 고려하는 것이 중요함을 알 수 있습니다.
